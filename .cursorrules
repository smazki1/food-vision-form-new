# Food Vision AI - Project Intelligence

## Latest Development Insights (January 2, 2025)

### âœ… Hebrew Character Storage Path Resolution - Critical Success Pattern
**Breakthrough**: Successfully resolved Supabase Storage "Invalid key" errors for Hebrew characters in file paths.

**Root Cause Discovered**: Hebrew text like "×¢×•×’×”" in storage paths causes failures because Supabase Storage requires ASCII-safe paths.

**Proven Solution Pattern**:
```typescript
const sanitizePathComponent = (text: string): string => {
  // 1. Hebrew word mapping for food industry terms
  const hebrewToEnglish = {
    '×× ×”': 'dish', '×©×ª×™×”': 'drink', '×§×•×§×˜×™×™×œ': 'cocktail',
    '×¢×•×’×”': 'cake', '×××¤×”': 'pastry', '×¡×œ×˜': 'salad',
    '×¢×•×£': 'chicken', '×‘×©×¨': 'meat', '×“×’': 'fish',
    '×™×¨×§×•×ª': 'vegetables', '×¤×™×¨×•×ª': 'fruits'
  };
  
  // 2. Replace whole Hebrew words first
  // 3. Convert remaining Hebrew chars to dashes
  // 4. Sanitize special characters
  // 5. Normalize dashes (collapse multiples, trim)
};
```

**Critical Storage Pattern**: Always sanitize item types in paths:
- Before: `leads/{leadId}/{hebrewItemType}/` âŒ FAILS
- After: `leads/{leadId}/{sanitizedItemType}/` âœ… WORKS

### âœ… Lightbox Navigation System - Production Success
**Latest Achievement**: Implemented comprehensive image navigation in lightbox mode with full testing coverage.

**Features Implemented**:
1. **Arrow Navigation**: Left/right arrows for navigating between images in lightbox
2. **Keyboard Support**: Arrow keys (â† â†’) work for navigation
3. **Circular Navigation**: Seamless loop from last to first image
4. **Multi-Component Integration**: 6 components updated with navigation support

**Critical Implementation Pattern**:
```typescript
// Updated function signatures for navigation support:
setLightboxImage: (imageUrl: string | null, images?: string[]) => void

// Components updated:
- SubmissionsSection.tsx: Added navigation props to LightboxDialog
- SubmissionProcessingPage.tsx: Enhanced lightbox with navigation
- OriginalImagesTabContent.tsx: Updated to pass image arrays
- ImagesTabContent.tsx: Updated for processed image arrays
- ContentTabs.tsx and SubmissionProcessingContent.tsx: Updated interfaces
```

**useLightbox Hook Enhancement**:
```typescript
// Fixed issues with empty arrays and string handling
const useLightbox = () => {
  // Handle both single images and arrays
  // Provide navigation state and controls
  // Support keyboard events
  // Circular navigation logic
};
```

### âœ… Comparison Mode with Navigation - Complete Implementation
**Latest Achievement**: Implemented smooth before/after image comparison with arrow navigation in submission viewer.

**Features Implemented**:
1. **Side-by-Side Comparison**: "×œ×¤× ×™" (before) and "××—×¨×™" (after) sections with large single images
2. **Arrow Navigation**: Left/right chevron buttons for navigating between multiple images in each section
3. **Image Counters**: Shows current position (e.g., "2 / 5") for both original and processed images
4. **Independent Navigation**: Original and processed images navigate separately
5. **Circular Navigation**: Seamless loop from last to first image and vice versa
6. **Mode Switching**: Toggle between comparison, grid, and gallery modes
7. **Lightbox Integration**: Click any image to open in fullscreen with existing lightbox navigation

**Critical Implementation Pattern**:
```typescript
// Navigation state for comparison mode
const [currentOriginalIndex, setCurrentOriginalIndex] = useState(0);
const [currentProcessedIndex, setCurrentProcessedIndex] = useState(0);

// Navigation functions with circular logic
const navigateOriginalImage = (direction: 'prev' | 'next') => {
  if (!submission.original_image_urls || submission.original_image_urls.length === 0) return;
  
  if (direction === 'prev') {
    setCurrentOriginalIndex(prev => 
      prev === 0 ? submission.original_image_urls!.length - 1 : prev - 1
    );
  } else {
    setCurrentOriginalIndex(prev => 
      prev === submission.original_image_urls!.length - 1 ? 0 : prev + 1
    );
  }
};

// Reset indices when switching to comparison mode
useEffect(() => {
  if (imageViewMode === 'comparison') {
    setCurrentOriginalIndex(0);
    setCurrentProcessedIndex(0);
  }
}, [imageViewMode]);
```

**UI Structure Pattern**:
```typescript
{imageViewMode === 'comparison' ? (
  <div className="grid grid-cols-2 gap-6">
    {/* Before - Original Images */}
    <div className="bg-gray-50 rounded-lg p-6">
      <h3>×œ×¤× ×™ - ×ª××•× ×•×ª ××§×•×¨</h3>
      <Badge>{currentOriginalIndex + 1} / {submission.original_image_urls.length}</Badge>
      
      <div className="relative">
        <img src={submission.original_image_urls[currentOriginalIndex]} />
        
        {/* Navigation arrows */}
        <Button onClick={() => navigateOriginalImage('prev')}>
          <ChevronLeft />
        </Button>
        <Button onClick={() => navigateOriginalImage('next')}>
          <ChevronRight />
        </Button>
      </div>
    </div>
    
    {/* After - Processed Images */}
    <div className="bg-gray-50 rounded-lg p-6">
      <h3>××—×¨×™ - ×ª××•× ×•×ª ××¢×•×‘×“×•×ª</h3>
      <Badge>{currentProcessedIndex + 1} / {submission.processed_image_urls.length}</Badge>
      
      <div className="relative">
        <img src={submission.processed_image_urls[currentProcessedIndex]} />
        
        {/* Navigation arrows + action buttons */}
        <Button onClick={() => navigateProcessedImage('prev')}>
          <ChevronLeft />
        </Button>
        <Button onClick={() => navigateProcessedImage('next')}>
          <ChevronRight />
        </Button>
        
        {/* Download/Delete overlay */}
        <div className="absolute inset-0 ... pointer-events-none group">
          <Button className="pointer-events-auto">
            <Download />
          </Button>
        </div>
      </div>
    </div>
  </div>
) : (
  /* Grid/Gallery Mode - Original Layout */
  <div className="grid gap-6 grid-cols-1">
    {/* Original grid layout preserved */}
  </div>
)}
```

**Build Success**: Clean TypeScript build (4.81s) with no breaking changes to existing functionality

### âœ… Client Submission Display Consistency - Complete Implementation  
**Latest Achievement**: Made client submission display work exactly like leads page with Sheet component pattern.

**Problem Solved**: Client window showed submissions inline below, while leads page opened submissions in new window/panel
**Solution Applied**: Changed client submissions to use same Sheet component pattern as leads page

**Implementation Pattern**:
```typescript
// Add Sheet state management
const [isViewerOpen, setIsViewerOpen] = React.useState(false);

const handleViewSubmission = (submissionId: string) => {
  setSelectedSubmissionId(submissionId);
  setIsViewerOpen(true); // Open sheet
};

const handleCloseViewer = () => {
  setIsViewerOpen(false);
  setSelectedSubmissionId(null);
};

// Use Sheet component instead of inline SubmissionViewer
<Sheet open={isViewerOpen} onOpenChange={setIsViewerOpen}>
  <SheetContent className="max-w-[95vw] sm:max-w-[90vw] p-0 h-full overflow-y-auto">
    <SubmissionViewer
      submissionId={selectedSubmissionId}
      viewMode="admin"
      context="full-page"
      onClose={handleCloseViewer}
    />
  </SheetContent>
</Sheet>
```

**UI/UX Success**: Now both leads and client windows behave consistently - clicking "×”×¦×’" opens submission in side panel

### âœ… Processed Images Delete Functionality - Complete Implementation
**Latest Achievement**: Added delete functionality for processed images alongside existing download buttons.

**Implementation Features**:
1. **Delete Button**: Red delete button appears next to download button on hover
2. **Admin-Only Access**: Delete buttons only visible in admin mode (`viewMode === 'admin'`)
3. **Event Isolation**: Delete actions don't trigger lightbox opening
4. **Database Updates**: Removes image from processed_image_urls array and clears main_processed_image_url if deleted
5. **UI Feedback**: Hebrew toast messages for successful deletion

**UI/UX Pattern**:
```typescript
// Action buttons overlay with both download and delete
<div className="absolute inset-0 ... pointer-events-none">
  <div className="flex items-center gap-2 opacity-0 group-hover:opacity-100">
    <Button variant="secondary" className="pointer-events-auto">
      <Download className="h-4 w-4" />
    </Button>
    {viewMode === 'admin' && (
      <Button variant="destructive" className="pointer-events-auto">
        <Trash2 className="h-4 w-4" />
      </Button>
    )}
  </div>
</div>
```

**Delete Function Pattern**:
```typescript
const handleDeleteProcessedImage = async (imageUrl: string) => {
  const currentImages = submission.processed_image_urls || [];
  const updatedImages = currentImages.filter(url => url !== imageUrl);
  
  const updateData: any = { processed_image_urls: updatedImages };
  
  // Clear main image if we're deleting it
  if (submission.main_processed_image_url === imageUrl) {
    updateData.main_processed_image_url = null;
  }

  await supabase.from('customer_submissions').update(updateData);
  toast.success("×”×ª××•× ×” × ××—×§×” ×‘×”×¦×œ×—×”");
};
```

### âœ… Processed Images Fullscreen - Critical Pointer Events Fix
**Breakthrough**: Resolved processed images click-to-open functionality with CSS pointer events solution.

**Root Cause Discovered**: Overlay div with `absolute inset-0` was blocking image clicks due to covering entire image area.

**Proven Solution Pattern**:
```typescript
// CRITICAL CSS FIX - Use these exact classes:
<div className="absolute inset-0 ... pointer-events-none"> {/* Allows clicks through */}
  <Button className="... pointer-events-auto"> {/* Keeps button clickable */}
    Download
  </Button>
</div>

// CRITICAL JavaScript pattern:
onClick={(e) => {
  e.stopPropagation(); // Prevents event bubbling
  onImageClick(url);
}}
```

**UI/UX Success Pattern**:
- **Click images** â†’ Open in fullscreen lightbox with navigation
- **Download buttons** â†’ Work independently without triggering lightbox  
- **Delete buttons** â†’ Admin-only, work independently without triggering lightbox
- **Hover effects** â†’ Visual feedback with opacity transitions
- **Cross-platform** â†’ Works in both admin and customer interfaces

**Testing Coverage - 21/21 Tests Passing**:
- Core functionality (image rendering, click handling)
- Delete functionality (admin/client mode, correct image targeting)
- Pointer events fix (CSS classes verification)
- Event propagation (button isolation)
- Hover effects and visual feedback
- Edge cases (empty arrays, invalid URLs)

**Critical Storage Configuration**:
```typescript
// CORRECT - Use this bucket for all uploads:
.from('food-vision-images')

// WRONG - This causes 400 errors:
.from('food-vision-uploads')
```

### âœ… Database Schema Verification via Supabase API
**Learning**: When database columns are missing, use Supabase Management API to verify actual schema instead of guessing.

**Proven Pattern**:
```typescript
// Use mcp_supabase_list_tables to verify column existence
// Check columns by ordinal_position and name
// Only use columns that actually exist in production database
```

**Column Existence Confirmed** (customer_submissions table):
- âœ… `branding_material_urls` (TEXT[] column 25) - EXISTS
- âœ… `reference_example_urls` (TEXT[] column 26) - EXISTS
- âœ… `description` (TEXT column 27) - EXISTS
- âŒ `internal_team_notes` - MAY NOT EXIST (migration-dependent)

**Safe Database Insert Pattern**:
```typescript
const submissionData = {
  // Always include core existing columns
  lead_id, item_type, item_name_at_submission, submission_status, original_image_urls,
  // Conditionally include verified columns
  ...(columnExists('branding_material_urls') ? { branding_material_urls } : {}),
  // Combine related fields if needed
  description: [description, specialNotes].filter(Boolean).join('\n\n×”×¢×¨×•×ª: ')
};
```

### âœ… Multi-File Upload Architecture Excellence
**Pattern**: Support multiple file types with unified UI but separate storage organization.

**Proven Implementation**:
1. **Separate Upload Handlers**: Each file type has its own upload logic
2. **Parallel Processing**: Use Promise.all() for simultaneous uploads
3. **Error Isolation**: Individual file failures don't break entire upload
4. **Memory Management**: Proper cleanup with URL.revokeObjectURL()
5. **Progress Feedback**: Hebrew toast messages for each stage

**Storage Organization Pattern**:
```
leads/{leadId}/{sanitizedItemType}/product/     # Product images
leads/{leadId}/{sanitizedItemType}/branding/    # Company branding  
leads/{leadId}/{sanitizedItemType}/reference/   # Reference examples
```

## Core Architecture Patterns

### Admin vs Customer Data Access Separation
**Critical Pattern**: Admin and customer users have fundamentally different data access patterns:
- **Admin users**: No client records, access all data via admin-specific hooks and RLS policies
- **Customer users**: Tied to specific client records, access data through client-filtered hooks
- **Implementation**: Create separate hook files (`useAdminSubmissions.ts` vs `useSubmissions.ts`) to handle these different access patterns
- **Database**: Use direct queries for admin, RLS policies with client filters for customers

### Database RLS (Row Level Security) Management
**Key Learning**: RLS policies can be complex and sometimes require temporary solutions:
- **Admin access**: Create temp policies like `temp_admin_access_all_submissions` for authenticated users when complex RPC functions fail
- **Simple queries**: Prefer direct table queries over complex RPC functions to avoid 400 errors
- **Separate data fetching**: Use separate queries for related data (client, lead) instead of complex joins
- **Enhanced logging**: Always add comprehensive console logging for debugging database access

### Component Conditional Logic for Multi-Role Support
**Pattern**: Components serving both admin and customer users need conditional logic:
```typescript
// Example from SubmissionViewer
const shouldUseAdminHooks = viewMode === 'admin' || viewMode === 'editor';
const submission = shouldUseAdminHooks 
  ? useAdminSubmission(submissionId) 
  : useSubmission(submissionId);
```
- **Route-based detection**: Use URL paths or view mode props to determine user context
- **Hook selection**: Conditionally choose appropriate hooks based on user role
- **Link generation**: Admin links should use `/admin/` routes, customer links use `/customer/`

## CRM Development Insights

### Always-Editable Interface Philosophy
**User Preference**: Notion-like editing experience is strongly preferred:
- **No edit mode**: Remove edit/save/cancel buttons entirely
- **Inline editing**: Click any field to edit directly with auto-save
- **Real-time feedback**: Hebrew toast messages for successful updates
- **Visual consistency**: All fields should look editable and accessible

### Smart Selector Components
**Pattern**: Business type and lead source selectors should be expandable:
- **Predefined options**: Offer common choices for quick selection
- **Free text input**: Allow custom values that get auto-saved for future use
- **Auto-value addition**: Current field values automatically added to dropdown if missing
- **Database persistence**: New values saved to respective tables for reuse

### Lead Management System Architecture
**Database Design**: Lead management requires multiple interconnected tables:
- **Core lead data**: `leads` table with restaurant, contact, status information
- **Activity tracking**: `lead_activities` table for timeline and comments
- **Cost tracking**: Fields for AI training costs, revenue, ROI calculations
- **Follow-up system**: Scheduled follow-ups with templates and automation

## Technical Implementation Patterns

### Query Key Management
**Critical**: Use consistent query key patterns for cache invalidation:
```typescript
const LEAD_QUERY_KEY = ['leads'] as const;
// Invalidate with: queryClient.invalidateQueries({ queryKey: LEAD_QUERY_KEY });
```

### Error Handling and Debugging
**Best Practice**: Always implement comprehensive logging:
- **Hook entry points**: Log function entry with parameters
- **Database queries**: Log query execution and results
- **Error states**: Log errors with context information
- **Success states**: Log successful operations with data

### Authentication State Management
**Learned Solution**: Handle token refresh gracefully:
- **Background refresh**: TOKEN_REFRESHED events should refresh quietly without UI reset
- **Cache preservation**: Avoid clearing cache during token refresh
- **Recovery mechanisms**: Implement emergency recovery for white screen issues
- **Timeout handling**: Use reasonable timeouts (5-15 seconds) to prevent infinite loops

## File Organization Insights

### Hook Organization
**Pattern**: Separate hooks by user role and functionality:
- `src/hooks/useSubmissions.ts` - Customer-specific submission hooks
- `src/hooks/useAdminSubmissions.ts` - Admin-specific submission hooks
- `src/hooks/admin/` - Directory for admin-specific functionality
- `src/hooks/__tests__/` - Keep tests alongside hooks with `.tsx` extension for JSX

### Component Structure
**Pattern**: Admin components should be self-contained:
- `src/components/admin/` - All admin-specific components
- `src/pages/admin/` - Admin page components
- `src/components/customer/` - Customer-specific components
- Clear separation prevents accidental cross-contamination

## Memory Bank Integration

### Documentation Philosophy
**Critical**: Memory bank files are essential for context preservation:
- **activeContext.md**: Current work focus and immediate next steps
- **progress.md**: Completed features with implementation details
- **systemPatterns.md**: Architecture decisions and patterns
- **Always update**: Keep memory bank current after significant changes

### Project Phases and Planning
**Pattern**: Break complex features into phases:
1. **Database schema**: Start with migrations and database structure
2. **Basic functionality**: Implement core features without UI polish
3. **UI enhancement**: Add visual polish and user experience improvements
4. **Integration**: Connect with existing systems
5. **Testing and deployment**: Comprehensive testing and production deployment

## Current System Status (2025-01-02)

### âœ… Completed Systems
- **Hebrew Submissions**: Complete path sanitization with comprehensive testing (9+ tests)
- **Lightbox Navigation System**: Complete image navigation with arrow controls and keyboard support
- **Processed Images Fullscreen**: Click-to-open functionality with pointer events fix (17/17 tests passing)
- **Branding Materials**: Full multi-file upload with database integration
- **Package Management**: Complete CRUD with comprehensive testing (22+ tests)
- **Authentication**: Stable with timeout handling and recovery
- **Admin Interface**: Full CRM with lead management and submission access
- **Upload Forms**: All three submission paths working (unified, public, legacy)
- **Database**: Optimized schema with proper RLS policies
- **Webhook Integration**: Complete Make.com integration deployed
- **Submissions Management**: Advanced filtering, bulk operations, visual thumbnails

### ğŸš€ Latest Production Deployment
- **URL**: https://food-vision-form-5ag87yn2x-avis-projects-a35edf10.vercel.app
- **Build Time**: 4.84s (improved from 5.25s)
- **Status**: âœ… LIVE AND OPERATIONAL
- **Features**: All Hebrew fixes, lightbox navigation, and processed images fullscreen functionality deployed

### ğŸ¯ Next Development Areas
- **Enhanced analytics**: Dashboard improvements for business intelligence
- **Mobile responsiveness**: Ensure admin interface works on mobile
- **Performance optimization**: Code splitting for large bundles
- **Documentation**: User guides and training materials

### âš ï¸ Critical Success Patterns
- **Hebrew Storage Paths**: Always use sanitizePathComponent() for item types in storage paths
- **Storage Bucket**: Use 'food-vision-images' not 'food-vision-uploads' for all uploads
- **Pointer Events Fix**: Use `pointer-events-none` on overlays, `pointer-events-auto` on interactive elements
- **Lightbox Navigation**: Always pass image arrays to support arrow navigation between images
- **React Query Refetch**: Use refetch() instead of window.location.reload() for data updates
- **Database Column Verification**: Verify column existence via Supabase API before using
- **Multi-File Uploads**: Test all three file types (product, branding, reference) together
- **Test coverage**: Continue expanding test suite for new features - achieved 17/17 passing tests for lightbox

## User Feedback Integration
**Key Learning**: User feedback drives feature priorities:
- **Hebrew Language Support**: Critical for Israeli market - always test with Hebrew characters
- **Multi-File Upload Workflows**: Users need to upload various file types per submission
- **Visual consistency**: Hebrew language support and RTL layout critical
- **Performance**: Fast response times more important than feature complexity
- **Simplicity**: Remove unnecessary steps and buttons from workflows 