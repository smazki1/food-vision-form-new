# Food Vision AI - Project Intelligence

## Latest Development Insights (January 2, 2025)

### ✅ Direct Package Assignment System - Production Success Pattern
**Breakthrough**: Successfully resolved critical package assignment issue where users couldn't assign packages to clients.

**Root Cause Discovered**: Database null values in package total_images field were not handled properly, causing button disable logic to fail.

**Proven Solution Pattern**:
```typescript
// PROBLEM: Database null values not handled properly
// Some packages had total_images: null instead of 0
const isDisabled = newServingsCount <= 0 && newImagesCount <= 0; // FAILED

// SOLUTION: Proper null handling throughout codebase
const totalImages = selectedPackage?.total_images ?? 0;
const totalServings = selectedPackage?.total_servings ?? 0;
// Used nullish coalescing (??) instead of logical OR (||)

// DIRECT ASSIGNMENT IMPLEMENTATION:
const handleDirectPackageAssignment = async (packageId: string) => {
  if (isLoading) return; // Prevent multiple clicks
  
  setIsLoading(true);
  try {
    const selectedPackage = packages.find(p => p.id === packageId);
    const assignedServings = Math.max(1, totalServings, totalImages);
    
    await assignPackageToClientWithImages(packageId, clientId, assignedServings);
    
    toast.success("חבילה הוקצתה בהצלחה ללקוח!");
    await queryClient.invalidateQueries({ queryKey: ['client'] });
  } catch (error) {
    toast.error("שגיאה בהקצאת החבילה");
  } finally {
    setIsLoading(false);
  }
};
```

**Critical Implementation Changes**:
- **Removed Dialog Component**: Eliminated entire AssignPackageDialog (900+ lines of complex logic)
- **Direct Assignment**: Click package → immediate assignment with loading feedback
- **Null Handling**: Proper database null value handling with ?? operator
- **User Experience**: Hebrew success messages and loading states
- **Code Cleanup**: Significant simplification and maintainability improvement

**Database Discovery Method**: Used Supabase Management API to verify actual schema:
- ✅ **"חבילה סטנדרטית"**: total_images: null → Required null handling
- ✅ **"חבילה פרימיום"**: total_images: null → Required null handling  
- ✅ **"חבילה מתקדמת"**: total_images: 50 → Worked correctly

**Production Results**:
- ✅ **Clean Build**: 4.88s compilation with zero TypeScript errors
- ✅ **Vercel Deployment**: https://food-vision-form-eno1fot11-avis-projects-a35edf10.vercel.app
- ✅ **User Experience**: Intuitive one-click assignment flow
- ✅ **Performance**: Fast assignment with immediate UI updates
- ✅ **Error Handling**: Comprehensive error catching with Hebrew messages

### ✅ Hebrew Character Storage Path Resolution - Critical Success Pattern
**Breakthrough**: Successfully resolved Supabase Storage "Invalid key" errors for Hebrew characters in file paths.

**Root Cause Discovered**: Hebrew text like "עוגה" in storage paths causes failures because Supabase Storage requires ASCII-safe paths.

**Proven Solution Pattern**:
```typescript
const sanitizePathComponent = (text: string): string => {
  // 1. Hebrew word mapping for food industry terms
  const hebrewToEnglish = {
    'מנה': 'dish', 'שתיה': 'drink', 'קוקטייל': 'cocktail',
    'עוגה': 'cake', 'מאפה': 'pastry', 'סלט': 'salad',
    'עוף': 'chicken', 'בשר': 'meat', 'דג': 'fish',
    'ירקות': 'vegetables', 'פירות': 'fruits'
  };
  
  // 2. Replace whole Hebrew words first
  // 3. Convert remaining Hebrew chars to dashes
  // 4. Sanitize special characters
  // 5. Normalize dashes (collapse multiples, trim)
};
```

**Critical Storage Pattern**: Always sanitize item types in paths:
- Before: `leads/{leadId}/{hebrewItemType}/` ❌ FAILS
- After: `leads/{leadId}/{sanitizedItemType}/` ✅ WORKS

### ✅ Lightbox Navigation System - Production Success
**Latest Achievement**: Implemented comprehensive image navigation in lightbox mode with full testing coverage.

**Features Implemented**:
1. **Arrow Navigation**: Left/right arrows for navigating between images in lightbox
2. **Keyboard Support**: Arrow keys (← →) work for navigation
3. **Circular Navigation**: Seamless loop from last to first image
4. **Multi-Component Integration**: 6 components updated with navigation support

**Critical Implementation Pattern**:
```typescript
// Updated function signatures for navigation support:
setLightboxImage: (imageUrl: string | null, images?: string[]) => void

// Components updated:
- SubmissionsSection.tsx: Added navigation props to LightboxDialog
- SubmissionProcessingPage.tsx: Enhanced lightbox with navigation
- OriginalImagesTabContent.tsx: Updated to pass image arrays
- ImagesTabContent.tsx: Updated for processed image arrays
- ContentTabs.tsx and SubmissionProcessingContent.tsx: Updated interfaces
```

**useLightbox Hook Enhancement**:
```typescript
// Fixed issues with empty arrays and string handling
const useLightbox = () => {
  // Handle both single images and arrays
  // Provide navigation state and controls
  // Support keyboard events
  // Circular navigation logic
};
```

### ✅ Comparison Mode with Navigation - Complete Implementation
**Latest Achievement**: Implemented smooth before/after image comparison with arrow navigation in submission viewer.

**Features Implemented**:
1. **Side-by-Side Comparison**: "לפני" (before) and "אחרי" (after) sections with large single images
2. **Arrow Navigation**: Left/right chevron buttons for navigating between multiple images in each section
3. **Image Counters**: Shows current position (e.g., "2 / 5") for both original and processed images
4. **Independent Navigation**: Original and processed images navigate separately
5. **Circular Navigation**: Seamless loop from last to first image and vice versa
6. **Mode Switching**: Toggle between comparison, grid, and gallery modes
7. **Lightbox Integration**: Click any image to open in fullscreen with existing lightbox navigation

**Critical Implementation Pattern**:
```typescript
// Navigation state for comparison mode
const [currentOriginalIndex, setCurrentOriginalIndex] = useState(0);
const [currentProcessedIndex, setCurrentProcessedIndex] = useState(0);

// Navigation functions with circular logic
const navigateOriginalImage = (direction: 'prev' | 'next') => {
  if (!submission.original_image_urls || submission.original_image_urls.length === 0) return;
  
  if (direction === 'prev') {
    setCurrentOriginalIndex(prev => 
      prev === 0 ? submission.original_image_urls!.length - 1 : prev - 1
    );
  } else {
    setCurrentOriginalIndex(prev => 
      prev === submission.original_image_urls!.length - 1 ? 0 : prev + 1
    );
  }
};

// Reset indices when switching to comparison mode
useEffect(() => {
  if (imageViewMode === 'comparison') {
    setCurrentOriginalIndex(0);
    setCurrentProcessedIndex(0);
  }
}, [imageViewMode]);
```

**UI Structure Pattern**:
```typescript
{imageViewMode === 'comparison' ? (
  <div className="grid grid-cols-2 gap-6">
    {/* Before - Original Images */}
    <div className="bg-gray-50 rounded-lg p-6">
      <h3>לפני - תמונות מקור</h3>
      <Badge>{currentOriginalIndex + 1} / {submission.original_image_urls.length}</Badge>
      
      <div className="relative">
        <img src={submission.original_image_urls[currentOriginalIndex]} />
        
        {/* Navigation arrows */}
        <Button onClick={() => navigateOriginalImage('prev')}>
          <ChevronLeft />
        </Button>
        <Button onClick={() => navigateOriginalImage('next')}>
          <ChevronRight />
        </Button>
      </div>
    </div>
    
    {/* After - Processed Images */}
    <div className="bg-gray-50 rounded-lg p-6">
      <h3>אחרי - תמונות מעובדות</h3>
      <Badge>{currentProcessedIndex + 1} / {submission.processed_image_urls.length}</Badge>
      
      <div className="relative">
        <img src={submission.processed_image_urls[currentProcessedIndex]} />
        
        {/* Navigation arrows + action buttons */}
        <Button onClick={() => navigateProcessedImage('prev')}>
          <ChevronLeft />
        </Button>
        <Button onClick={() => navigateProcessedImage('next')}>
          <ChevronRight />
        </Button>
        
        {/* Download/Delete overlay */}
        <div className="absolute inset-0 ... pointer-events-none group">
          <Button className="pointer-events-auto">
            <Download />
          </Button>
        </div>
      </div>
    </div>
  </div>
) : (
  /* Grid/Gallery Mode - Original Layout */
  <div className="grid gap-6 grid-cols-1">
    {/* Original grid layout preserved */}
  </div>
)}
```

**Build Success**: Clean TypeScript build (4.81s) with no breaking changes to existing functionality

### ✅ Client Submission Display Consistency - Complete Implementation  
**Latest Achievement**: Made client submission display work exactly like leads page with Sheet component pattern.

**Problem Solved**: Client window showed submissions inline below, while leads page opened submissions in new window/panel
**Solution Applied**: Changed client submissions to use same Sheet component pattern as leads page

**Implementation Pattern**:
```typescript
// Add Sheet state management
const [isViewerOpen, setIsViewerOpen] = React.useState(false);

const handleViewSubmission = (submissionId: string) => {
  setSelectedSubmissionId(submissionId);
  setIsViewerOpen(true); // Open sheet
};

const handleCloseViewer = () => {
  setIsViewerOpen(false);
  setSelectedSubmissionId(null);
};

// Use Sheet component instead of inline SubmissionViewer
<Sheet open={isViewerOpen} onOpenChange={setIsViewerOpen}>
  <SheetContent className="max-w-[95vw] sm:max-w-[90vw] p-0 h-full overflow-y-auto">
    <SubmissionViewer
      submissionId={selectedSubmissionId}
      viewMode="admin"
      context="full-page"
      onClose={handleCloseViewer}
    />
  </SheetContent>
</Sheet>
```

**UI/UX Success**: Now both leads and client windows behave consistently - clicking "הצג" opens submission in side panel

### ✅ Processed Images Delete Functionality - Complete Implementation
**Latest Achievement**: Added delete functionality for processed images alongside existing download buttons.

**Implementation Features**:
1. **Delete Button**: Red delete button appears next to download button on hover
2. **Admin-Only Access**: Delete buttons only visible in admin mode (`viewMode === 'admin'`)
3. **Event Isolation**: Delete actions don't trigger lightbox opening
4. **Database Updates**: Removes image from processed_image_urls array and clears main_processed_image_url if deleted
5. **UI Feedback**: Hebrew toast messages for successful deletion

**UI/UX Pattern**:
```typescript
// Action buttons overlay with both download and delete
<div className="absolute inset-0 ... pointer-events-none">
  <div className="flex items-center gap-2 opacity-0 group-hover:opacity-100">
    <Button variant="secondary" className="pointer-events-auto">
      <Download className="h-4 w-4" />
    </Button>
    {viewMode === 'admin' && (
      <Button variant="destructive" className="pointer-events-auto">
        <Trash2 className="h-4 w-4" />
      </Button>
    )}
  </div>
</div>
```

**Delete Function Pattern**:
```typescript
const handleDeleteProcessedImage = async (imageUrl: string) => {
  const currentImages = submission.processed_image_urls || [];
  const updatedImages = currentImages.filter(url => url !== imageUrl);
  
  const updateData: any = { processed_image_urls: updatedImages };
  
  // Clear main image if we're deleting it
  if (submission.main_processed_image_url === imageUrl) {
    updateData.main_processed_image_url = null;
  }

  await supabase.from('customer_submissions').update(updateData);
  toast.success("התמונה נמחקה בהצלחה");
};
```

### ✅ Processed Images Fullscreen - Critical Pointer Events Fix
**Breakthrough**: Resolved processed images click-to-open functionality with CSS pointer events solution.

**Root Cause Discovered**: Overlay div with `absolute inset-0` was blocking image clicks due to covering entire image area.

**Proven Solution Pattern**:
```typescript
// CRITICAL CSS FIX - Use these exact classes:
<div className="absolute inset-0 ... pointer-events-none"> {/* Allows clicks through */}
  <Button className="... pointer-events-auto"> {/* Keeps button clickable */}
    Download
  </Button>
</div>

// CRITICAL JavaScript pattern:
onClick={(e) => {
  e.stopPropagation(); // Prevents event bubbling
  onImageClick(url);
}}
```

**UI/UX Success Pattern**:
- **Click images** → Open in fullscreen lightbox with navigation
- **Download buttons** → Work independently without triggering lightbox  
- **Delete buttons** → Admin-only, work independently without triggering lightbox
- **Hover effects** → Visual feedback with opacity transitions
- **Cross-platform** → Works in both admin and customer interfaces

**Testing Coverage - 21/21 Tests Passing**:
- Core functionality (image rendering, click handling)
- Delete functionality (admin/client mode, correct image targeting)
- Pointer events fix (CSS classes verification)
- Event propagation (button isolation)
- Hover effects and visual feedback
- Edge cases (empty arrays, invalid URLs)

**Critical Storage Configuration**:
```typescript
// CORRECT - Use this bucket for all uploads:
.from('food-vision-images')

// WRONG - This causes 400 errors:
.from('food-vision-uploads')
```

### ✅ Database Schema Verification via Supabase API
**Learning**: When database columns are missing, use Supabase Management API to verify actual schema instead of guessing.

**Proven Pattern**:
```typescript
// Use mcp_supabase_list_tables to verify column existence
// Check columns by ordinal_position and name
// Only use columns that actually exist in production database
```

**Column Existence Confirmed** (customer_submissions table):
- ✅ `branding_material_urls` (TEXT[] column 25) - EXISTS
- ✅ `reference_example_urls` (TEXT[] column 26) - EXISTS
- ✅ `description` (TEXT column 27) - EXISTS
- ❌ `internal_team_notes` - MAY NOT EXIST (migration-dependent)

**Safe Database Insert Pattern**:
```typescript
const submissionData = {
  // Always include core existing columns
  lead_id, item_type, item_name_at_submission, submission_status, original_image_urls,
  // Conditionally include verified columns
  ...(columnExists('branding_material_urls') ? { branding_material_urls } : {}),
  // Combine related fields if needed
  description: [description, specialNotes].filter(Boolean).join('\n\nהערות: ')
};
```

### ✅ Multi-File Upload Architecture Excellence
**Pattern**: Support multiple file types with unified UI but separate storage organization.

**Proven Implementation**:
1. **Separate Upload Handlers**: Each file type has its own upload logic
2. **Parallel Processing**: Use Promise.all() for simultaneous uploads
3. **Error Isolation**: Individual file failures don't break entire upload
4. **Memory Management**: Proper cleanup with URL.revokeObjectURL()
5. **Progress Feedback**: Hebrew toast messages for each stage

**Storage Organization Pattern**:
```
leads/{leadId}/{sanitizedItemType}/product/     # Product images
leads/{leadId}/{sanitizedItemType}/branding/    # Company branding  
leads/{leadId}/{sanitizedItemType}/reference/   # Reference examples
```

## Core Architecture Patterns

### Admin vs Customer Data Access Separation
**Critical Pattern**: Admin and customer users have fundamentally different data access patterns:
- **Admin users**: No client records, access all data via admin-specific hooks and RLS policies
- **Customer users**: Tied to specific client records, access data through client-filtered hooks
- **Implementation**: Create separate hook files (`useAdminSubmissions.ts` vs `useSubmissions.ts`) to handle these different access patterns
- **Database**: Use direct queries for admin, RLS policies with client filters for customers

### Database RLS (Row Level Security) Management
**Key Learning**: RLS policies can be complex and sometimes require temporary solutions:
- **Admin access**: Create temp policies like `temp_admin_access_all_submissions` for authenticated users when complex RPC functions fail
- **Simple queries**: Prefer direct table queries over complex RPC functions to avoid 400 errors
- **Separate data fetching**: Use separate queries for related data (client, lead) instead of complex joins
- **Enhanced logging**: Always add comprehensive console logging for debugging database access

### Component Conditional Logic for Multi-Role Support
**Pattern**: Components serving both admin and customer users need conditional logic:
```typescript
// Example from SubmissionViewer
const shouldUseAdminHooks = viewMode === 'admin' || viewMode === 'editor';
const submission = shouldUseAdminHooks 
  ? useAdminSubmission(submissionId) 
  : useSubmission(submissionId);
```
- **Route-based detection**: Use URL paths or view mode props to determine user context
- **Hook selection**: Conditionally choose appropriate hooks based on user role
- **Link generation**: Admin links should use `/admin/` routes, customer links use `/customer/`

## CRM Development Insights

### Always-Editable Interface Philosophy
**User Preference**: Notion-like editing experience is strongly preferred:
- **No edit mode**: Remove edit/save/cancel buttons entirely
- **Inline editing**: Click any field to edit directly with auto-save
- **Real-time feedback**: Hebrew toast messages for successful updates
- **Visual consistency**: All fields should look editable and accessible

### Smart Selector Components
**Pattern**: Business type and lead source selectors should be expandable:
- **Predefined options**: Offer common choices for quick selection
- **Free text input**: Allow custom values that get auto-saved for future use
- **Auto-value addition**: Current field values automatically added to dropdown if missing
- **Database persistence**: New values saved to respective tables for reuse

### Lead Management System Architecture
**Database Design**: Lead management requires multiple interconnected tables:
- **Core lead data**: `leads` table with restaurant, contact, status information
- **Activity tracking**: `lead_activities` table for timeline and comments
- **Cost tracking**: Fields for AI training costs, revenue, ROI calculations
- **Follow-up system**: Scheduled follow-ups with templates and automation

## Technical Implementation Patterns

### Query Key Management
**Critical**: Use consistent query key patterns for cache invalidation:
```typescript
const LEAD_QUERY_KEY = ['leads'] as const;
// Invalidate with: queryClient.invalidateQueries({ queryKey: LEAD_QUERY_KEY });
```

### Error Handling and Debugging
**Best Practice**: Always implement comprehensive logging:
- **Hook entry points**: Log function entry with parameters
- **Database queries**: Log query execution and results
- **Error states**: Log errors with context information
- **Success states**: Log successful operations with data

### Authentication State Management
**Learned Solution**: Handle token refresh gracefully:
- **Background refresh**: TOKEN_REFRESHED events should refresh quietly without UI reset
- **Cache preservation**: Avoid clearing cache during token refresh
- **Recovery mechanisms**: Implement emergency recovery for white screen issues
- **Timeout handling**: Use reasonable timeouts (5-15 seconds) to prevent infinite loops

## File Organization Insights

### Hook Organization
**Pattern**: Separate hooks by user role and functionality:
- `src/hooks/useSubmissions.ts` - Customer-specific submission hooks
- `src/hooks/useAdminSubmissions.ts` - Admin-specific submission hooks
- `src/hooks/admin/` - Directory for admin-specific functionality
- `src/hooks/__tests__/` - Keep tests alongside hooks with `.tsx` extension for JSX

### Component Structure
**Pattern**: Admin components should be self-contained:
- `src/components/admin/` - All admin-specific components
- `src/pages/admin/` - Admin page components
- `src/components/customer/` - Customer-specific components
- Clear separation prevents accidental cross-contamination

## Memory Bank Integration

### Documentation Philosophy
**Critical**: Memory bank files are essential for context preservation:
- **activeContext.md**: Current work focus and immediate next steps
- **progress.md**: Completed features with implementation details
- **systemPatterns.md**: Architecture decisions and patterns
- **Always update**: Keep memory bank current after significant changes

### Project Phases and Planning
**Pattern**: Break complex features into phases:
1. **Database schema**: Start with migrations and database structure
2. **Basic functionality**: Implement core features without UI polish
3. **UI enhancement**: Add visual polish and user experience improvements
4. **Integration**: Connect with existing systems
5. **Testing and deployment**: Comprehensive testing and production deployment

## Current System Status (2025-01-02)

### ✅ Completed Systems
- **Hebrew Submissions**: Complete path sanitization with comprehensive testing (9+ tests)
- **Lightbox Navigation System**: Complete image navigation with arrow controls and keyboard support
- **Processed Images Fullscreen**: Click-to-open functionality with pointer events fix (17/17 tests passing)
- **Branding Materials**: Full multi-file upload with database integration
- **Package Management**: Complete CRUD with comprehensive testing (22+ tests)
- **Authentication**: Stable with timeout handling and recovery
- **Admin Interface**: Full CRM with lead management and submission access
- **Upload Forms**: All three submission paths working (unified, public, legacy)
- **Database**: Optimized schema with proper RLS policies
- **Webhook Integration**: Complete Make.com integration deployed
- **Submissions Management**: Advanced filtering, bulk operations, visual thumbnails

### 🚀 Latest Production Deployment
- **URL**: https://food-vision-form-5ag87yn2x-avis-projects-a35edf10.vercel.app
- **Build Time**: 4.84s (improved from 5.25s)
- **Status**: ✅ LIVE AND OPERATIONAL
- **Features**: All Hebrew fixes, lightbox navigation, and processed images fullscreen functionality deployed

### 🎯 Next Development Areas
- **Enhanced analytics**: Dashboard improvements for business intelligence
- **Mobile responsiveness**: Ensure admin interface works on mobile
- **Performance optimization**: Code splitting for large bundles
- **Documentation**: User guides and training materials

### ⚠️ Critical Success Patterns
- **Hebrew Storage Paths**: Always use sanitizePathComponent() for item types in storage paths
- **Storage Bucket**: Use 'food-vision-images' not 'food-vision-uploads' for all uploads
- **Pointer Events Fix**: Use `pointer-events-none` on overlays, `pointer-events-auto` on interactive elements
- **Lightbox Navigation**: Always pass image arrays to support arrow navigation between images
- **React Query Refetch**: Use refetch() instead of window.location.reload() for data updates
- **Database Column Verification**: Verify column existence via Supabase API before using
- **Multi-File Uploads**: Test all three file types (product, branding, reference) together
- **Test coverage**: Continue expanding test suite for new features - achieved 17/17 passing tests for lightbox

## User Feedback Integration
**Key Learning**: User feedback drives feature priorities:
- **Hebrew Language Support**: Critical for Israeli market - always test with Hebrew characters
- **Multi-File Upload Workflows**: Users need to upload various file types per submission
- **Visual consistency**: Hebrew language support and RTL layout critical
- **Performance**: Fast response times more important than feature complexity
- **Simplicity**: Remove unnecessary steps and buttons from workflows 